# Project Goals

## The goal is to use Python/Manim (Manim Community Edition) to create animations according to the paths output from a discrete time simulator or a calculated model. The spatial and temporal aspects of the model are 3D space and 1D time populated with geometric point potentials that move according to the laws of physics provided by an action function. The 3D space is Euclidean.  1D time is linear and forward moving.  The ultimate goal is to create a library of reusable animation objects and scenes so that new visualizations can leverage the existing objects, scenes, and internal data structures.

### 1. While generating the animation of the simulation in 3D space and 1D time a function will be used to scale, translate, and rotate the configuration of points for each frame of the animation. 

### 2. A key concepts of the simulation and animation is the path history of each point potential. The path history of each point potential must be retained for a tunable number of simulation intervals. In some cases we will ask for tracers that highlight the path history of the point potential through space and time.

### 3. It is important to keep the simulation coordinate system separate from the manim coordinate system.  That way it can scale accordingly to map the particle positions to the manim coordinate system. Keeping the simulation coordinate system separate from the Manim coordinate system is a good idea because it allows you to handle scaling, translation, and rotation independently of the simulation logic. Here's a step-by-step approach to achieve this:

---

### 1. **Separate Coordinate Systems**
   - **Simulation Coordinates**: These are the coordinates generated by the discrete-time simulator. They represent the positions of point potentials in 3D space over time.
   - **Manim Coordinates**: These are the coordinates used by Manim to render the animation. Manim uses a 3D coordinate system where the origin is at the center of the screen.
   - **Mapping between coordinate systems**: You need to define a mapping between these two coordinate systems. This mapping will allow you to scale, translate, and rotate the simulation coordinates to fit within the Manim coordinate system.
   - **Displaying the Mapping**: A legend area on the animation will show the simulation scale (logarithmically), the translational velocity, and the camera orientation in theta and phi.

---

### 2. **Mapping Simulation Coordinates to Manim Coordinates**
   - **Scaling**: If your simulation coordinates are in a different range (e.g., nanometers or astronomical units), you need to scale them to fit within Manim's coordinate system. For example, if your simulation coordinates range from `-1000` to `1000` and you want them to fit within Manim's `-5` to `5` range, you can apply a scaling factor.
   - **Translation**: If your simulation coordinates are offset from the origin, you may need to translate them so that the center of your simulation aligns with Manim's origin.
   - **Rotation**: If your simulation coordinates are oriented differently from Manim's coordinate system, you can apply a rotation transformation.

   You can use a transformation matrix or a function to map simulation coordinates to Manim coordinates. For example:

   ```python
   def map_to_manim(sim_x, sim_y, sim_z):
       scale_factor = 0.01  # Example scaling factor
       translation = np.array([2, -1, 0])  # Example translation
       rotation_matrix = np.array([[1, 0, 0], [0, 0, -1], [0, 1, 0]])  # Example rotation

       sim_coords = np.array([sim_x, sim_y, sim_z])
       manim_coords = scale_factor * np.dot(rotation_matrix, sim_coords) + translation
       return manim_coords
   ```
When point potentials in the simulation space move beyond the manim display space, then scale the coordinates to fit in the mainim display space.  Show the scale factor in the upper right corner of each frame.
---

### 3. **Loading Simulation Data**
   - Track the simulated data path (a path is the history of particle position and velocity for each simulation tick). New path information will be generated on the fly from the action module.
   - Store the data in a structure like a list of dictionaries or a NumPy array, where each entry represents the state of the system at a specific time step.

   Example:
   ```python
   simulation_data = [
       {"time": 0, "particles": [(x1, y1, z1, dx1/dt, dy1/dt, dz1/dt), (x2, y2, z2, dx2/dt, dy2/dt, dz2/dt), ...]},
       {"time": 1, "particles": [(x1, y1, z1, dx1/dt, dy1/dt, dz1/dt), (x2, y2, z2, dx2/dt, dy2/dt, dz2/dt), ...]},
       ...
   ]
   ```

---

### 4. **Creating the Animation in Manim**
   - Use Manim's `ThreeDScene` to create a 3D animation.
   - For each time step in the simulation data, update the positions of the particles in the Manim scene.
   - Use the mapping function to convert simulation coordinates to Manim coordinates.

   Example:
   ```python
   from manim import *

   class ParticleSimulation(ThreeDScene):
       def construct(self):
           # Load simulation data
           simulation_data = load_simulation_data()

           # Create dots for particles
           particles = [Dot3D() for _ in simulation_data[0]["particles"]]
           self.add(*particles)

           # Animate particle motion
           for time_step in simulation_data:
               for particle, (sim_x, sim_y, sim_z) in zip(particles, time_step["particles"]):
                   manim_x, manim_y, manim_z = map_to_manim(sim_x, sim_y, sim_z)
                   particle.move_to([manim_x, manim_y, manim_z])
               self.wait(0.1)  # Adjust frame rate
   ```

---

### 5. **Adding Camera Controls**
   - Use Manim's camera controls to allow scaling, translation, and rotation of the view during the animation.
   - Example:
     ```python
     self.move_camera(phi=45 * DEGREES, theta=-45 * DEGREES, zoom=1.5)
     ```

---

### 6. **Optimization**
   - If your simulation has many particles or time steps, consider optimizing the animation by:
     - Using Manim's `ValueTracker` and `Updater` to interpolate between time steps.

---

### 7. **Testing and Debugging**
   - Test the animation with a small subset of your simulation data to ensure the mapping and animation logic work as expected.
   - Debug any issues with scaling, translation, or rotation by visualizing the mapped coordinates.

---

### 8. **Input Parameters from a JSON file**
   - All parameters for the simulation must be specified in a JSON file, and that file name will be a command line argument.
   - Default values should be specified for all parameters possible in the input file to handle when they are missing.
   - Default values in the python code should all be specified near the head of the file.
   - Parameters include
      - Initial position and velocity of each point potential in the simulation at time t=0. The elements are (q, x, y, z, dx/dt, dy/dt, dz/dt), 
      - q is the charge polarity, i.e., + or -.
      - Color codes to use for each type of point potential.
      - Color code for the background 3D space.
      - Size of the circular marker for point potentials.
      - Enable/disable path history tracer, tracer color code, number of simulation ticks to display trace history, trace fading on/off.
      - Action function to be used to compute next simulation result from the prior simulation clock tick.
      - Duration of simulation in simulation ticks.
      - Ratio of simulation ticks to manim frame ticks
      - Manim frame rate
      - Choice of action function from a set of action functions, where action calculates the forces and updates velocity and position.

By following this approach, you can create a flexible and scalable animation system that separates the simulation logic from the rendering logic, allowing you to easily adjust the visualization as needed.

---

### 9. **Testing and Validation**
   - Test the simulation with a small number of particles to ensure the classification and update logic work correctly.
   - Validate the results by comparing them to a simulation where all particles are updated at the same frequency.

---

### 10. **Appearance**
   - The background will be purple, code INDIGO = "#4B0082"
   - Use Dot3D to depict point potentials
   - Positive point potentials have color PURE_RED and a radius of 0.04
   - Negative point potentials have color PURE_BLUE and a radius of 0.04
   - Trailing path colors are configurable on a per simulation basis in the sim*.json file.
      - The default option is RED (#FC6255) for positive point potentials, and BLUE (#58C4DD) for negative point potentials
      - An second option is that all point potentials have a WHITE tracer.

---

### 11. **Tracers**

   - There can be multiple types of tracers requested. Some may be overlaid on another.
   - Line Tracer: Tracers can be a curve that follows the last N ticks of path for each point potential.
      - A 1 unit wide line should be the default, and this is specifiable in the json input file.
      - The color of the tracer lines is specifiable in the json input file.
         - One option is thin white lines for all point potentials
         - A second option is pale red for the positive point potentials and pale blue for the negative point potentials.
   - Dot3D Tracer: This tracer displays spaced copies of the point potential along its own path history.
      - The opacity of these Dot3D tracers varies from 80% and decreases to 10% over the number of tracer points specified in the json input file.
      - Tracer colors: pale red for the positive point potentials and pale blue for the negative point potentials.
      - Tracer point locations are chosen based on equal time intervals, which will give some indication of velocity by the spacing.

---

### 12. **Selectable Action Functions**

   - The architecture will allow the action function for the simulation to be chosen in the json input file.
   - Many action functions will be developed, so design for one action function per python source file.
   - Use the convention that action function source files be named action_<identifer>
   - The first action function will be the one currently implemented. Name the file action_basic.py
   - The API for action functions, i.e., the calling parameters includes the path history for all point potentials in the simulation.
   - Path history is defined as (t, x, y, z, dx/dt, dy/dt, dz/dt) where position and velocity are vectors.
   - Each action function must determine the next time step in the path of all point potentials.

---

### 13. **Path History Action Function**

   - The action_basic.py action function presumes that the spherical potential wave emitted by each point potential travels infinitely fast such that the current position of the emitting point potential is used to calculate the action on the receiving point potential.
   - The action_history.py action function will use the speed of the spherical potential wave, potential_velocity, to calculate action based on the intersecting potential wave emitted on the path history of the emitter.  Potential velocity should be set in the input sim*.json file.
   - The algorithm requires searching through the path history and finding the emission time and radius to the receiver that most closely matches the current position of the receiver.
   - Here are the details of the action algorithm between a receiver and a transmitter:

   1. Start with the current receiver and emitter positions
   2. Calculate the radial distance between them as our initial "best distance"
   3. For each historical point n*dt back in time:
      - Calculate where the potential wave from that point would be now
      - Calculate the distance between that wave position and the receiver's current position
      - If this distance is smaller than our current "best distance", update our best history point

   To calculate where the potential wave from a historical point would be now:
   - The wave expands at potential_velocity in all directions
   - After n*dt time, the wave has traveled a distance of n*dt*potential_velocity
   - The wave front would be a sphere centered at the historical emitter position, with radius ndtpotential_velocity

   So for each historical point, we need to:
   1. Calculate the distance between that historical emitter position and the current receiver position
   2. Compare that to how far the wave from that point would have traveled (ndtpotential_velocity)
   3. The difference between these values tells us how close the wave front is to the receiver

   The closest match is where the difference is minimized.

   - Use the calculated history point (location and velocity) for the action calculation.
   - Proceed through all possible emitters.
   - Move on to the next receiver and repeat the process until all receiver path histories are updated for the next step.
   - The speed of the potential wave is set in the physics section of the configuration file, as the potential_velocity parameter. 
   - The default value is 10.0, but you can adjust it to different values to see how it affects the simulation.
   - When the action function is set to "history", it determines how fast the potential waves from the emitter particles travel through space. 
   - Lower values cause the potential waves to travel more slowly, thus the action forces are based on older positions in the emitter's history. 
   - Higher values make the potential waves travel faster, approaching the behavior of the basic action function as the value gets very large.


---

### 14. **Logarithmic Spiral Action Function**

   - The action_spiral.py action function provides a geometric (rather than physics-based) model where particles follow logarithmic spiral paths.
   - Unlike the basic and history action functions which use Coulomb's law to calculate forces, this action function directly updates particle positions along predetermined spiral paths.
   - Each particle follows a logarithmic spiral defined by the formula: r = a*e^(k*θ), where:
     - a is the starting radius (set to 1.0)
     - k is the spiral growth factor (positive values create outward spirals, negative values create inward spirals)
     - θ is the angle parameter that increases over time
   
   - Key parameters for the spiral action function in the JSON configuration file:
     - spiral_k: The growth factor that determines how quickly the spiral expands or contracts (default: 0.1)
     - theta_rate: Controls how quickly particles advance along the spiral path (default: 200, smaller values = faster motion)
     - z_factor: Controls how quickly particles move in the z-dimension for 3D effects (default: 0.05)
   
   - Implementation details:
     1. Each particle is assigned a spiral based on its charge: positive charges spiral outward (k > 0), negative charges spiral inward (k < 0)
     2. At each simulation step, the angle θ is increased by π/theta_rate for each particle
     3. The new x, y, z coordinates are calculated using the logarithmic spiral formula
     4. The velocity is approximated based on position changes for visualization purposes only
   
   - This action function demonstrates how the simulation architecture can support not just physics-based models but also pure geometric motions, allowing for creative and aesthetically interesting visualizations.
   - To use this action function, create a configuration file with "action_function": "spiral" and include the spiral-specific parameters in the physics section.

---

### 15. **Configuration File Conventions**

   - The project uses a tiered approach to configuration files that balances completeness with clarity:
     
   - **Example Configuration File**:
     - `example_config.json` serves as the comprehensive reference
     - Contains all possible configuration options with default values
     - Should be kept up-to-date whenever new options are added
     - Acts as documentation for available parameters
     - Note that standard JSON doesn't support comments, so parameter descriptions should be documented in this design file and the README.md

   - **Specific Simulation Configuration Files**:
     - `sim*.json` files should be concise and focused
     - Include only parameters that are:
       1. Required for simulation (e.g., particles, action_function)
       2. Different from the default values
       3. Essential to understanding the purpose of that particular simulation
     - Omit parameters that use default values to keep files clean and readable
     - Each config file should demonstrate a specific concept or physics model

   - **Code Default Handling**:
     - All parameters should have sensible defaults in the code
     - Default values should be documented at the top of their respective files
     - The simulator should robustly handle missing parameters
     - A consistent merging system should apply defaults for any missing values

   - **Parameter Organization**:
     - Parameters are organized into logical sections:
       - `simulation`: Controls simulation behavior, particles, and time steps
       - `physics`: Controls physical constants and behavior specific to action functions
       - `visualization`: Controls visual representation and animation properties
     - New action functions should add their parameters to the appropriate section

   This approach provides the benefits of both comprehensive documentation and clean, focused configuration files. Users can refer to the example file to discover all options while creating minimal configuration files for specific simulations.

---

